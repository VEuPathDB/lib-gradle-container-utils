package org.veupathdb.lib.gradle.container.tasks.base.build;

import org.gradle.api.tasks.Internal;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.veupathdb.lib.gradle.container.tasks.base.Action;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.Collection;

/**
 * Build Action
 * <p>
 * Base class for dependency building tasks.
 *
 * @since 1.1.0
 */
public abstract class BuildAction extends Action {

  /**
   * State where the current task's target has not yet been built, or has
   * been completely wiped out, meaning a new download, build, and install is
   * needed.
   *
   * @since 1.1.0
   */
  protected final byte StateNew    = 1;

  /**
   * State where the current task's target has been built, but the configured
   * version of the dependency has been updated in the Gradle build file.
   *
   * @since 1.1.0
   */
  protected final byte StateUpdate = 2;

  /**
   * State where the current task's target has been built and is at the version
   * currently configured in the Gradle build file.
   *
   * @since 1.1.0
   */
  protected final byte StateSkip   = 127;

  /**
   * Lazily populated root build directory.
   * <p>
   * Typically the bin or vendor directory.
   *
   * @since 1.1.0
   */
  @Nullable
  private File buildDirectory;

  //
  //
  // Abstract Methods
  //
  //

  /**
   * Returns the name of the dependency this {@code BuildAction} will build.
   *
   * @since 1.1.0
   */
  @Internal
  @NotNull
  protected abstract String getDependencyName();

  /**
   * Returns a {@code File} instance representing a lock file for the built
   * dependency.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the lock file actually
   * exists.
   *
   * @since 1.1.0
   */
  @Internal
  @NotNull
  protected abstract File getLockFile();

  /**
   * Returns the root directory where dependencies will be located once built.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the dependency root
   * directory actually exists.
   *
   * @since 1.1.0
   */
  @Internal
  @NotNull
  protected abstract File getDependencyRoot();

  /**
   * Build dependency project and install it in the target location.
   *
   * @since 1.1.0
   */
  protected abstract void install();

  /**
   * Performs the action or actions necessary to retrieve the dependency's
   * source code.
   *
   * @return The directory containing the unpacked source files required to
   * build the dependency.
   *
   * @since 1.1.0
   */
  @NotNull
  protected abstract File download();

  /**
   * Removes all artifacts generated by the dependency install.  Additionally,
   * deletes the lock file for the dependency.
   *
   * @since 1.1.0
   */
  protected abstract void clean();

  /**
   * Return the build configuration for the specific build.
   *
   * @return the build configuration for the specific build.
   *
   * @since 2.0.0
   */
  protected abstract BuildConfiguration buildConfiguration();

  /**
   * Return the global build configuration.
   *
   * @return the global build configuration.
   *
   * @since 2.0.0
   */
  protected abstract GlobalBuildConfiguration globalBuildConfiguration();

  //
  //
  // Instance Methods
  //
  //

  @Override
  public void fillIncrementalOutputFiles(@NotNull Collection<File> files) {
    super.fillIncrementalOutputFiles(files);
    files.add(getLockFile());
  }

  /**
   * Returns the target directory for the built artifacts from this task.
   * <p>
   * This will typically be the bin or vendor directory.
   *
   * @return The target directory for the built artifacts from this task.
   *
   * @since 1.1.0
   */
  @Internal
  @NotNull
  protected File getBuildTargetDirectory() {
    log().open();

    if (buildDirectory == null)
      throw new IllegalStateException("Cannot get build directory before it's been created.");

    return log().close(buildDirectory);
  }

  @Override
  public void execute() {
    log().open();

    log().info("Checking {}", this::getDependencyName);

    final var state = determineState();
    switch (state) {
      case StateNew -> {
        log().info("Not Found. Installing.");
        createBuildRootIfNotExists();
      }
      case StateUpdate -> {
        log().info("Version change detected. Updating.");
        clean();
      }
      case StateSkip -> {
        log().info("Already up to date. Skipping.");
        log().close();
        return;
      }
      default -> {
        log().error("Unrecognized state {}", state);
        throw new RuntimeException("Unrecognized state " + state);
      }
    }

    buildDirectory = download();
    install();
    writeLockFile();
    postBuildCleanup();

    log().close();
  }

  /**
   * Returns the version of the dependency built in the last full run of this
   * task as recorded in the build's lock file.
   *
   * @return Previously built version of this dependency.
   *
   * @since 1.1.0
   */
  @Internal
  @NotNull
  protected String getLockVersion() {
    return log().getter(util().readFile(getLockFile()));
  }

  /**
   * Deletes the build directory for the installed dependency.
   *
   * @since 1.1.0
   */
  protected void postBuildCleanup() {
    log().open();
    log().debug("Beginning post build cleanup.");

    util().deleteRecursive(getBuildTargetDirectory());

    log().close();
  }

  /**
   * Determines what action needs to be taken (if any) for the current
   * installation.
   *
   * @return One of {@link #StateNew}, {@link #StateUpdate}, or
   * {@link #StateSkip}.
   *
   * @since 1.1.0
   */
  protected byte determineState() {
    log().open();

    if (!getDependencyRoot().exists() || !getLockFile().exists())
      return log().close(StateNew);

    return log().close(
      getLockVersion().equals(buildConfiguration().getTargetVersion())
        ? StateSkip
        : StateUpdate
    );
  }

  /**
   * Writes the just built dependency version to the task's target lock file.
   *
   * @since 1.1.0
   */
  protected void writeLockFile() {
    log().open();

    try {
      Files.writeString(
        getLockFile().toPath(),
        buildConfiguration().getTargetVersion(),
        StandardOpenOption.CREATE,
        StandardOpenOption.TRUNCATE_EXISTING
      );
    } catch (Exception e) {
      log().error("Failed to write lock file " + getLockFile());
      throw new RuntimeException("Failed to write lock file " + getLockFile(), e);
    }

    log().close();
  }

  /**
   * Creates the build root (see {@link #getDependencyRoot()}) if it does not
   * already exist.
   *
   * @see #getDependencyRoot()
   *
   * @since 1.1.0
   */
  protected void createBuildRootIfNotExists() {
    log().open();

    final var dir = getDependencyRoot();

    if (!dir.exists() && !dir.mkdirs()) {
      log().error("Failed to create build root " + dir);
      throw new RuntimeException("Failed to create build root " + dir);
    }

    log().close();
  }

}

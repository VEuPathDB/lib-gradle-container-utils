package org.veupathdb.lib.gradle.container.tasks.base;

import org.gradle.api.tasks.Internal;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;

public abstract class BuildAction extends Action {

  protected final byte StateNew    = 1;
  protected final byte StateUpdate = 2;
  protected final byte StateSkip   = 127;

  private File buildDirectory;

  /**
   * Returns the name of the dependency this {@code BuildAction} will build.
   */
  @Internal
  @NotNull
  protected abstract String getDependencyName();

  /**
   * Returns a {@code File} instance representing a lock file for the built
   * dependency.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the lock file actually
   * exists.
   */
  @Internal
  @NotNull
  protected abstract File getLockFile();

  /**
   * Returns the version of this dependency configured at the plugin level.
   */
  @Internal
  @NotNull
  protected abstract String getConfiguredVersion();

  /**
   * Returns the root directory where dependencies will be located once built.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the dependency root
   * directory actually exists.
   */
  @Internal
  @NotNull
  protected abstract File getDependencyRoot();

  /**
   * Build dependency project and install it in the target location.
   */
  protected abstract void install();

  /**
   * Performs the action or actions necessary to retrieve the dependency's
   * source code.
   *
   * @return The directory containing the unpacked source files required to
   * build the dependency.
   */
  @NotNull
  protected abstract File download();

  /**
   * Removes all artifacts generated by the dependency install.  Additionally,
   * deletes the lock file for the dependency.
   */
  protected abstract void clean();

  @Internal
  @NotNull
  protected File getBuildTargetDirectory() {
    Log.open("BuildAction#getBuildTargetDirectory()");

    if (buildDirectory == null)
      throw new IllegalStateException("Cannot get build directory before it's been created.");

    return Log.close(buildDirectory);
  }

  @Override
  protected void execute() {
    Log.open("InstallAction#execute()");

    Log.info("Checking " + getDependencyName());

    final var state = determineState();
    switch (state) {
      case StateNew -> {
        Log.info("  Not Found. Installing.");
        createBuildRootIfNotExists();
      }
      case StateUpdate -> {
        Log.info("  Version change detected. Updating.");
        clean();
      }
      case StateSkip -> {
        Log.info("  Already up to date. Skipping.");
        return;
      }
      default -> {
        Log.error("Unrecognized state " + state);
        throw new RuntimeException("Unrecognized state " + state);
      }
    }

    buildDirectory = download();
    install();
    writeLockFile();
    postBuildCleanup();

    Log.close();
  }

  @Internal
  @NotNull
  protected String getLockVersion() {
    return Log.getter(Util.readFile(getLockFile()));
  }

  /**
   * Deletes the build directory for the installed dependency.
   */
  protected void postBuildCleanup() {
    Log.open("InstallAction#removeBuildDir()");
    Log.debug("Beginning post build cleanup.");

    Util.deleteRecursive(getBuildTargetDirectory());

    Log.close();
  }

  /**
   * Determines what action needs to be taken (if any) for the current
   * installation.
   *
   * @return One of {@link #StateNew}, {@link #StateUpdate}, or
   * {@link #StateSkip}.
   */
  protected byte determineState() {
    Log.open("BuildAction#determineState()");

    if (!getDependencyRoot().exists() || !getLockFile().exists())
      return Log.close(StateNew);

    return Log.close(
      getLockVersion().equals(getConfiguredVersion())
        ? StateSkip
        : StateUpdate
    );
  }

  protected void writeLockFile() {
    Log.open("BuildAction#writeLockFile()");

    try {
      Files.writeString(
        getLockFile().toPath(),
        getConfiguredVersion(),
        StandardOpenOption.CREATE,
        StandardOpenOption.TRUNCATE_EXISTING
      );
    } catch (Exception e) {
      Log.error("Failed to write lock file " + getLockFile());
      throw new RuntimeException("Failed to write lock file " + getLockFile(), e);
    }

    Log.close();
  }

  protected void createBuildRootIfNotExists() {
    Log.open("BuildAction#createBuildRootIfNotExists()");

    final var dir = getDependencyRoot();

    if (!dir.exists() && !dir.mkdirs()) {
      Log.error("Failed to create build root " + dir);
      throw new RuntimeException("Failed to create build root " + dir);
    }

    Log.close();
  }
}

package org.veupathdb.lib.gradle.container.tasks.base;

import org.gradle.api.tasks.Internal;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Comparator;

public abstract class BuildAction extends Action {

  protected final byte StateNew    = 1;
  protected final byte StateUpdate = 2;
  protected final byte StateSkip   = 127;

  private File buildDirectory;

  /**
   * Returns the name of the dependency this {@code BuildAction} will build.
   */
  @Internal
  protected abstract String getDependencyName();

  /**
   * Returns a {@code File} instance representing a lock file for the built
   * dependency.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the lock file actually
   * exists.
   */
  @Internal
  protected abstract File getLockFile();

  /**
   * Returns the version of this dependency configured at the plugin level.
   */
  @Internal
  protected abstract String getConfiguredVersion();

  /**
   * Returns the root directory where dependencies will be located once built.
   * <p>
   * <b>WARNING</b>: This method makes no guarantee that the dependency root
   * directory actually exists.
   */
  @Internal
  protected abstract File getDependencyRoot();

  /**
   * Build dependency project and install it in the target location.
   */
  protected abstract void install();

  /**
   * Performs the action or actions necessary to retrieve the dependency's
   * source code.
   *
   * @return The directory containing the unpacked source files required to
   * build the dependency.
   */
  protected abstract File download();

  /**
   * Removes all artifacts generated by the dependency install.  Additionally,
   * deletes the lock file for the dependency.
   */
  protected abstract void clean();

  @Internal
  protected File getBuildTargetDirectory() {
    if (buildDirectory == null)
      throw new IllegalStateException("Cannot get build directory before it's been created.");

    return buildDirectory;
  }

  @Override
  protected void execute() {
    Log.trace("InstallAction#execute()");

    final var state = determineState();
    switch (state) {
      case StateNew -> {
        System.out.println("Installing " + getDependencyName());
        createBuildRootIfNotExists();
      }
      case StateUpdate -> {
        System.out.println("Updating " + getDependencyName());
        clean();
      }
      case StateSkip -> System.out.println("Skipping " + getDependencyName() + ", no update needed.");
      default -> {
        Log.error("Unrecognized state " + state);
        throw new RuntimeException("Unrecognized state " + state);
      }
    }

    buildDirectory = download();
    install();
    writeLockFile();
    postBuildCleanup();
  }

  @Internal
  protected String getLockVersion() {
    Log.trace("InstallAction#getLockVersion()");

    try {
      return Files.readString(getLockFile().toPath());
    } catch (Exception e) {
      Log.error("Failed to read lock version for " + getLockFile());
      throw new RuntimeException("Failed to read lock version for " + getLockFile(), e);
    }
  }

  /**
   * Deletes the build directory for the installed dependency.
   */
  protected void postBuildCleanup() {
    Log.trace("InstallAction#removeBuildDir()");

    try {
      Utils.deleteRecursive(getBuildTargetDirectory());
    } catch (Exception e) {
      Log.error("Post build cleanup failed");
      throw new RuntimeException("Post build cleanup failed", e);
    }
  }

  /**
   * Determines what action needs to be taken (if any) for the current
   * installation.
   *
   * @return One of {@link #StateNew}, {@link #StateUpdate}, or
   * {@link #StateSkip}.
   */
  protected byte determineState() {
    Log.trace("BuildAction#determineState()");

    if (!getDependencyRoot().exists() || !getLockFile().exists())
      return StateNew;

    return getLockVersion().equals(getConfiguredVersion()) ? StateSkip : StateUpdate;
  }

  protected void writeLockFile() {
    Log.trace("BuildAction#writeLockFile()");

    try {
      Files.writeString(
        getLockFile().toPath(),
        getConfiguredVersion(),
        StandardOpenOption.CREATE,
        StandardOpenOption.TRUNCATE_EXISTING
      );
    } catch (Exception e) {
      Log.error("Failed to write lock file " + getLockFile());
      throw new RuntimeException("Failed to write lock file " + getLockFile(), e);
    }
  }

  protected void createBuildRootIfNotExists() {
    Log.trace("BuildAction#createBuildRootIfNotExists()");

    final var dir = getDependencyRoot();

    if (!dir.exists() && !dir.mkdirs()) {
      Log.error("Failed to create build root " + dir);
      throw new RuntimeException("Failed to create build root " + dir);
    }
  }
}
